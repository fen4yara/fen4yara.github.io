<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–ü–ª–∏–Ω–∫–æ ¬∑ 320xbet</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="game-page">
    <header class="glass-card top-bar">
      <div>
        <p class="eyebrow">–†–µ–∂–∏–º</p>
        <h1>üß© –ü–ª–∏–Ω–∫–æ</h1>
        <p class="muted">–ù–∞—Å—Ç—Ä–æ–π —Ä–∏—Å–∫ –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä—è–¥–æ–≤, –±—Ä–æ—Å–∞–π —à–∞—Ä –∏ –ª–æ–≤–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –º–Ω–æ–∂–∏—Ç–µ–ª—å.</p>
      </div>
      <button class="btn-outline" onclick="window.location.href='mainPage.html'">‚¨Ö –ù–∞–∑–∞–¥</button>
    </header>

    <section class="plinko-layout">
      <article class="glass-card plinko-controls">
        <div class="balance-pill">
          –ë–∞–ª–∞–Ω—Å: <span id="balance">...</span> üç¨
        </div>

        <label class="muted" for="betInput">–°—Ç–∞–≤–∫–∞</label>
        <input type="number" id="betInput" min="1" class="input-field" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å—Ç–∞–≤–∫—É" />

        <label class="muted">–†–∏—Å–∫</label>
        <div class="option-toggle">
          <button class="btn-secondary option-btn" data-risk="low">–ù–∏–∑–∫–∏–π</button>
          <button class="btn-secondary option-btn active" data-risk="medium">–°—Ä–µ–¥–Ω–∏–π</button>
          <button class="btn-secondary option-btn" data-risk="high">–í—ã—Å–æ–∫–∏–π</button>
        </div>

        <label class="muted" for="rowsSelect">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä—è–¥–æ–≤</label>
        <select id="rowsSelect" class="input-field"></select>

        <button id="dropBtn" class="btn-primary" style="margin-top: 12px;">–ë—Ä–æ—Å–∏—Ç—å —à–∞—Ä</button>
        <p id="plinkoMessage" class="message"></p>
      </article>

      <article class="glass-card plinko-board-card">
        <div class="plinko-board" id="plinkoBoard">
          <div class="plinko-pegs" id="plinkoPegLayer"></div>
          <div class="plinko-ball hidden" id="plinkoBall"></div>
        </div>
        <div class="plinko-payouts" id="plinkoPayouts"></div>
      </article>

      <article class="glass-card history-card">
        <p class="eyebrow">–ü–æ—Å–ª–µ–¥–Ω–∏–µ –ø–∞–¥–µ–Ω–∏—è</p>
        <div id="plinkoHistoryList" class="history-list"></div>
      </article>
    </section>
  </div>

  <script src="script/utils.js"></script>
  <script>
    const BASE_URL = 'https://fen4yaragithubio-production.up.railway.app';
    let user = null;
    let plinkoConfig = null;
    let selectedRisk = 'medium';
    let selectedRows = 12;
    let isAnimating = false;
    let highlightedSlot = null;

    const balanceEl = document.getElementById('balance');
    const betInput = document.getElementById('betInput');
    const rowsSelect = document.getElementById('rowsSelect');
    const riskButtons = document.querySelectorAll('[data-risk]');
    const dropBtn = document.getElementById('dropBtn');
    const messageEl = document.getElementById('plinkoMessage');
    const pegLayer = document.getElementById('plinkoPegLayer');
    const boardEl = document.getElementById('plinkoBoard');
    const ballEl = document.getElementById('plinkoBall');
    const payoutsEl = document.getElementById('plinkoPayouts');
    const historyList = document.getElementById('plinkoHistoryList');

    const riskTitles = {
      low: '–Ω–∏–∑–∫–∏–π',
      medium: '—Å—Ä–µ–¥–Ω–∏–π',
      high: '–≤—ã—Å–æ–∫–∏–π'
    };

    riskButtons.forEach((btn) => {
      btn.addEventListener('click', () => {
        if (isAnimating) return;
        selectedRisk = btn.dataset.risk;
        riskButtons.forEach((b) => b.classList.toggle('active', b === btn));
        renderPayouts();
      });
    });

    rowsSelect.addEventListener('change', () => {
      selectedRows = Number(rowsSelect.value);
      renderBoard();
    });

    dropBtn.addEventListener('click', () => {
      if (!isAnimating) {
        playPlinko();
      }
    });

    async function init() {
      try {
        const authResp = await fetch(`${BASE_URL}/check-auth`, { credentials: 'include' });
        if (!authResp.ok) throw new Error('–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω');
        user = await authResp.json();
        balanceEl.textContent = formatCoins(user.balance);

        const configResp = await fetch(`${BASE_URL}/plinko/config`, { credentials: 'include' });
        if (!configResp.ok) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é');
        plinkoConfig = await configResp.json();
        populateRowsSelect();
        renderBoard();
        await loadHistory();
      } catch (err) {
        alert(err.message || '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏');
        window.location.href = 'index.html';
      }
    }

    function populateRowsSelect() {
      rowsSelect.innerHTML = '';
      (plinkoConfig?.rows || []).forEach((row) => {
        const option = document.createElement('option');
        option.value = row;
        option.textContent = `${row} —Ä—è–¥–æ–≤`;
        if (row === selectedRows) option.selected = true;
        rowsSelect.appendChild(option);
      });
    }

    function renderBoard() {
      pegLayer.innerHTML = '';
      const rows = selectedRows;
      for (let r = 0; r < rows; r++) {
        const rowEl = document.createElement('div');
        rowEl.className = 'plinko-row';
        for (let c = 0; c <= r; c++) {
          const peg = document.createElement('span');
          peg.className = 'plinko-peg';
          rowEl.appendChild(peg);
        }
        pegLayer.appendChild(rowEl);
      }
      resetBall();
      renderPayouts();
    }

    function getMultipliers() {
      return plinkoConfig?.multipliers?.[selectedRisk]?.[selectedRows] || [];
    }

    function renderPayouts() {
      payoutsEl.innerHTML = '';
      highlightedSlot = null;
      const multipliers = getMultipliers();
      if (!multipliers.length) return;

      multipliers.forEach((mult, idx) => {
        const slot = document.createElement('div');
        slot.className = 'plinko-slot';
        slot.textContent = `${mult.toFixed(2)}x`;
        slot.dataset.index = idx;
        payoutsEl.appendChild(slot);
      });
    }

    function highlightSlot(index) {
      if (!payoutsEl.children.length) return;
      if (highlightedSlot !== null && payoutsEl.children[highlightedSlot]) {
        payoutsEl.children[highlightedSlot].classList.remove('highlight');
      }
      const slot = payoutsEl.children[index];
      if (slot) {
        slot.classList.add('highlight');
        highlightedSlot = index;
      }
    }

    function setMessage(text, tone = 'muted') {
      messageEl.textContent = text;
      messageEl.style.color =
        tone === 'error' ? 'var(--danger)' : tone === 'success' ? 'var(--success)' : 'var(--text-muted)';
    }

    async function playPlinko() {
      const bet = Number(betInput.value);
      if (!bet || bet <= 0) {
        setMessage('–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Ç–∞–≤–∫—É', 'error');
        return;
      }
      if (bet > user.balance) {
        setMessage('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤', 'error');
        return;
      }
      setMessage('');
      dropBtn.disabled = true;
      try {
        const resp = await fetch(`${BASE_URL}/plinko/play`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ bet, risk: selectedRisk, rows: selectedRows })
        });
        const data = await resp.json();
        if (!resp.ok) throw new Error(data.error || '–û—à–∏–±–∫–∞ —Å—Ç–∞–≤–∫–∏');

        user.balance = data.newBalance;
        balanceEl.textContent = formatCoins(user.balance);

        const net = data.payout - bet;
        const message = data.payout > 0
          ? `üéâ x${data.multiplier.toFixed(2)} ‚Üí ${formatSignedCandy(net)}`
          : '–ü—Ä–æ–∏–≥—Ä—ã—à. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞';
        setMessage(message, data.payout > 0 ? 'success' : 'muted');

        await animatePath(Array.isArray(data.path) ? data.path : [], data.bucket);
        renderHistory(data.history || []);
      } catch (err) {
        setMessage(err.message || '–û—à–∏–±–∫–∞', 'error');
      } finally {
        isAnimating = false;
        dropBtn.disabled = false;
      }
    }

    function animatePath(path, bucketIndex) {
      return new Promise((resolve) => {
        const steps = Array.isArray(path) && path.length ? path : [selectedRows / 2];
        const duration = 220;
        isAnimating = true;
        ballEl.classList.remove('hidden');
        const width = boardEl.clientWidth;
        const height = boardEl.clientHeight;
        const rowHeight = height / (selectedRows + 2);

        steps.forEach((value, idx) => {
          setTimeout(() => {
            const ratio = selectedRows === 0 ? 0.5 : value / selectedRows;
            const x = ratio * width;
            const y = idx * rowHeight;
            ballEl.style.transform = `translate(${x - 12}px, ${y}px)`;
            if (idx === steps.length - 1) {
              highlightSlot(bucketIndex);
              setTimeout(resolve, 200);
            }
          }, idx * duration);
        });
      });
    }

    function resetBall() {
      ballEl.classList.add('hidden');
      ballEl.style.transform = 'translate(-50%, -50%)';
      highlightedSlot = null;
      Array.from(payoutsEl.children).forEach((slot) => slot.classList.remove('highlight'));
    }

    async function loadHistory() {
      try {
        const resp = await fetch(`${BASE_URL}/plinko/history`, { credentials: 'include' });
        if (!resp.ok) return;
        const data = await resp.json();
        renderHistory(data);
      } catch (err) {
        console.error('plinko history error', err);
      }
    }

    function renderHistory(entries) {
      historyList.innerHTML = '';
      if (!Array.isArray(entries) || !entries.length) {
        historyList.innerHTML = '<div class="history-item muted">–ò—Å—Ç–æ—Ä–∏—è –ø–æ—è–≤–∏—Ç—Å—è –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–π –∏–≥—Ä—ã</div>';
        return;
      }
      entries.forEach((entry) => {
        const card = document.createElement('div');
        card.className = 'history-item';
        const date = new Date(entry.timestamp);
        const header = document.createElement('div');
        header.innerHTML = `<strong>${date.toLocaleTimeString('ru-RU')}</strong> ‚Äî ${entry.rows} —Ä—è–¥–æ–≤`;
        const body = document.createElement('div');
        body.className = 'muted';
        const net = (entry.payout || 0) - (entry.bet || 0);
        body.textContent = [
          `–†–∏—Å–∫: ${riskTitles[entry.risk] || entry.risk}`,
          `–°—Ç–∞–≤–∫–∞ ${formatCandy(entry.bet)}`,
          `x${Number(entry.multiplier || 0).toFixed(2)} ‚Üí ${formatSignedCandy(net)}`
        ].join(' ¬∑ ');
        card.appendChild(header);
        card.appendChild(body);
        historyList.appendChild(card);
      });
    }

    init();
  </script>
</body>
</html>

