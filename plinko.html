<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–ü–ª–∏–Ω–∫–æ ¬∑ 320xbet</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="game-page">
    <header class="glass-card top-bar">
      <div>
        <p class="eyebrow">–†–µ–∂–∏–º</p>
        <h1>üß© –ü–ª–∏–Ω–∫–æ</h1>
        <p class="muted">–ù–∞—Å—Ç—Ä–æ–π —Ä–∏—Å–∫ –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä—è–¥–æ–≤, –±—Ä–æ—Å–∞–π —à–∞—Ä –∏ –ª–æ–≤–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –º–Ω–æ–∂–∏—Ç–µ–ª—å.</p>
      </div>
      <button class="btn-outline" onclick="window.location.href='mainPage.html'">‚¨Ö –ù–∞–∑–∞–¥</button>
    </header>

    <section class="plinko-layout">
      <article class="glass-card plinko-controls">
        <div class="balance-pill">
          –ë–∞–ª–∞–Ω—Å: <span id="balance">...</span> üç¨
        </div>

        <label class="muted" for="betInput">–°—Ç–∞–≤–∫–∞</label>
        <input type="number" id="betInput" min="1" class="input-field" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å—Ç–∞–≤–∫—É" />

        <label class="muted">–†–∏—Å–∫</label>
        <div class="option-toggle">
          <button class="btn-secondary option-btn" data-risk="low">–ù–∏–∑–∫–∏–π</button>
          <button class="btn-secondary option-btn active" data-risk="medium">–°—Ä–µ–¥–Ω–∏–π</button>
          <button class="btn-secondary option-btn" data-risk="high">–í—ã—Å–æ–∫–∏–π</button>
        </div>

        <label class="muted" for="rowsSelect">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä—è–¥–æ–≤</label>
        <select id="rowsSelect" class="input-field"></select>

        <button id="dropBtn" class="btn-primary" style="margin-top: 12px;">–ë—Ä–æ—Å–∏—Ç—å —à–∞—Ä</button>
        <p id="plinkoMessage" class="message"></p>
      </article>

      <article class="glass-card plinko-board-card">
        <div class="plinko-board" id="plinkoBoard">
          <div class="plinko-pegs" id="plinkoPegLayer"></div>
          <div id="plinkoBallsContainer"></div>
        </div>
        <div class="plinko-payouts" id="plinkoPayouts"></div>
      </article>

      <article class="glass-card history-card">
        <p class="eyebrow">–ü–æ—Å–ª–µ–¥–Ω–∏–µ –ø–∞–¥–µ–Ω–∏—è</p>
        <div id="plinkoHistoryList" class="history-list"></div>
      </article>
    </section>
  </div>

  <script src="script/utils.js"></script>
  <script>
    const BASE_URL = 'https://infer.cfd';
    let user = null;
    let plinkoConfig = null;
    let selectedRisk = 'medium';
    let selectedRows = 12;
    let highlightedSlot = null;

    const balanceEl = document.getElementById('balance');
    const betInput = document.getElementById('betInput');
    const rowsSelect = document.getElementById('rowsSelect');
    const riskButtons = document.querySelectorAll('[data-risk]');
    const dropBtn = document.getElementById('dropBtn');
    const messageEl = document.getElementById('plinkoMessage');
    const pegLayer = document.getElementById('plinkoPegLayer');
    const boardEl = document.getElementById('plinkoBoard');
    const ballsContainer = document.getElementById('plinkoBallsContainer');
    const payoutsEl = document.getElementById('plinkoPayouts');
    const historyList = document.getElementById('plinkoHistoryList');

    const riskTitles = {
      low: '–Ω–∏–∑–∫–∏–π',
      medium: '—Å—Ä–µ–¥–Ω–∏–π',
      high: '–≤—ã—Å–æ–∫–∏–π'
    };

    riskButtons.forEach((btn) => {
      btn.addEventListener('click', () => {
        selectedRisk = btn.dataset.risk;
        riskButtons.forEach((b) => b.classList.toggle('active', b === btn));
        renderPayouts();
      });
    });

    rowsSelect.addEventListener('change', () => {
      selectedRows = Number(rowsSelect.value);
      renderBoard();
    });

    dropBtn.addEventListener('click', () => {
      // –†–∞–∑—Ä–µ—à–∞–µ–º –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω—ã–µ –Ω–∞–∂–∞—Ç–∏—è - –∫–∞–∂–¥—ã–π —Ä–∞–∑ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –Ω–æ–≤—ã–π —à–∞—Ä–∏–∫
      playPlinko();
    });

    async function init() {
      try {
        const authResp = await fetch(`${BASE_URL}/check-auth`, { credentials: 'include' });
        if (!authResp.ok) throw new Error('–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω');
        user = await authResp.json();
        balanceEl.textContent = formatCoins(user.balance, { decimals: 2 });

        const configResp = await fetch(`${BASE_URL}/plinko/config`, { credentials: 'include' });
        if (!configResp.ok) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é');
        plinkoConfig = await configResp.json();
        populateRowsSelect();
        renderBoard();
        await loadHistory();
      } catch (err) {
        alert(err.message || '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏');
        window.location.href = 'index.html';
      }
    }

    function populateRowsSelect() {
      rowsSelect.innerHTML = '';
      (plinkoConfig?.rows || []).forEach((row) => {
        const option = document.createElement('option');
        option.value = row;
        option.textContent = `${row} —Ä—è–¥–æ–≤`;
        if (row === selectedRows) option.selected = true;
        rowsSelect.appendChild(option);
      });
    }

    function renderBoard() {
      pegLayer.innerHTML = '';
      const rows = selectedRows;
      const boardPadding = 20;
      const boardWidth = boardEl.clientWidth - boardPadding * 2;
      const boardHeight = boardEl.clientHeight - boardPadding * 2;
      const rowHeight = boardHeight / (rows + 1);
      
      // –†–∞—Å—Å—Ç–∞–≤–ª—è–µ–º –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ –ø–æ –≤—Å–µ–π —à–∏—Ä–∏–Ω–µ –¥–æ—Å–∫–∏
      for (let r = 0; r < rows; r++) {
        const rowEl = document.createElement('div');
        rowEl.className = 'plinko-row';
        const pegsInRow = r + 1;
        
        // –†–∞–≤–Ω–æ–º–µ—Ä–Ω–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ –≤—Å–µ–π —à–∏—Ä–∏–Ω–µ –¥–æ—Å–∫–∏
        // –ü–µ—Ä–≤—ã–π –∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π peg –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–∞ –∫—Ä–∞—è—Ö —Å –Ω–µ–±–æ–ª—å—à–∏–º –æ—Ç—Å—Ç—É–ø–æ–º
        const edgePadding = 10; // –æ—Ç—Å—Ç—É–ø –æ—Ç –∫—Ä–∞–µ–≤
        const availableWidth = boardWidth - edgePadding * 2;
        const spacing = pegsInRow > 1 ? availableWidth / (pegsInRow - 1) : 0;
        
        for (let c = 0; c < pegsInRow; c++) {
          const peg = document.createElement('span');
          peg.className = 'plinko-peg';
          // –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –æ—Ç –ª–µ–≤–æ–≥–æ –∫—Ä–∞—è –¥–æ –ø—Ä–∞–≤–æ–≥–æ —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ
          let x;
          if (pegsInRow === 1) {
            x = boardWidth / 2 - 6; // —Ü–µ–Ω—Ç—Ä, –µ—Å–ª–∏ –æ–¥–∏–Ω peg
          } else {
            // –†–∞–≤–Ω–æ–º–µ—Ä–Ω–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ –≤—Å–µ–π —à–∏—Ä–∏–Ω–µ
            x = edgePadding + (c * spacing) - 6;
          }
          peg.style.left = `${x}px`;
          peg.style.position = 'absolute';
          rowEl.appendChild(peg);
        }
        rowEl.style.top = `${boardPadding + (r + 1) * rowHeight - 6}px`;
        rowEl.style.left = `${boardPadding}px`;
        rowEl.style.width = `${boardWidth}px`;
        rowEl.style.position = 'absolute';
        pegLayer.appendChild(rowEl);
      }
      clearAllBalls();
      renderPayouts();
    }

    function getMultipliers() {
      return plinkoConfig?.multipliers?.[selectedRisk]?.[selectedRows] || [];
    }

    function renderPayouts() {
      payoutsEl.innerHTML = '';
      highlightedSlot = null;
      const multipliers = getMultipliers();
      if (!multipliers.length) return;

      multipliers.forEach((mult, idx) => {
        const slot = document.createElement('div');
        slot.className = 'plinko-slot';
        slot.textContent = `${mult.toFixed(2)}x`;
        slot.dataset.index = idx;
        payoutsEl.appendChild(slot);
      });
    }

    function highlightSlot(index) {
      if (!payoutsEl.children.length) return;
      if (highlightedSlot !== null && payoutsEl.children[highlightedSlot]) {
        payoutsEl.children[highlightedSlot].classList.remove('highlight');
      }
      const slot = payoutsEl.children[index];
      if (slot) {
        slot.classList.add('highlight');
        highlightedSlot = index;
      }
    }

    function setMessage(text, tone = 'muted') {
      messageEl.textContent = text;
      messageEl.style.color =
        tone === 'error' ? 'var(--danger)' : tone === 'success' ? 'var(--success)' : 'var(--text-muted)';
    }

    async function playPlinko() {
      const bet = Number(betInput.value);
      if (!bet || bet <= 0) {
        setMessage('–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Ç–∞–≤–∫—É', 'error');
        return;
      }
      if (bet > user.balance) {
        setMessage('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤', 'error');
        return;
      }
      setMessage('');
      // –ù–µ –±–ª–æ–∫–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É, —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –∑–∞–ø—É—Å–∫–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —à–∞—Ä–∏–∫–æ–≤ –ø–æ–¥—Ä—è–¥
      try {
        const resp = await fetch(`${BASE_URL}/plinko/play`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ bet, risk: selectedRisk, rows: selectedRows, ballsCount: 1 })
        });
        const data = await resp.json();
        if (!resp.ok) throw new Error(data.error || '–û—à–∏–±–∫–∞ —Å—Ç–∞–≤–∫–∏');

        user.balance = data.newBalance;
        balanceEl.textContent = formatCoins(user.balance, { decimals: 2 });

        const net = data.totalPayout - data.totalBet;
        const message = data.totalPayout > 0
          ? `üéâ x${data.results[0].multiplier.toFixed(2)} ‚Üí ${formatSignedCandy(net)}`
          : '–ü—Ä–æ–∏–≥—Ä—ã—à. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞';
        setMessage(message, data.totalPayout > 0 ? 'success' : 'muted');

        // –ê–Ω–∏–º–∏—Ä—É–µ–º —à–∞—Ä–∏–∫
        await animatePath(data.results[0].path, data.results[0].bucket, 0);
        renderHistory(data.history || []);
      } catch (err) {
        setMessage(err.message || '–û—à–∏–±–∫–∞', 'error');
      }
    }

    function animatePath(path, bucketIndex, delay = 0) {
      return new Promise((resolve) => {
        if (!Array.isArray(path) || path.length === 0) {
          path = Array(selectedRows + 1).fill(selectedRows / 2);
        }
        const duration = 150;
        const boardPadding = 20;
        const width = boardEl.clientWidth - boardPadding * 2;
        const height = boardEl.clientHeight - boardPadding * 2;
        const rowHeight = height / (selectedRows + 1);
        const ballSize = 24;
        
        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç —à–∞—Ä–∏–∫–∞
        const ballEl = document.createElement('div');
        ballEl.className = 'plinko-ball';
        ballsContainer.appendChild(ballEl);
        
        // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è —à–∞—Ä–∏–∫–∞ - –ø–æ —Ü–µ–Ω—Ç—Ä—É —Å–≤–µ—Ä—Ö—É
        const startX = width / 2;
        const startY = 0;
        ballEl.style.left = `${boardPadding + startX - ballSize / 2}px`;
        ballEl.style.top = `${boardPadding + startY}px`;
        ballEl.style.transition = '';

        path.forEach((value, idx) => {
          setTimeout(() => {
            let normalizedX;
            if (selectedRows === 0) {
              normalizedX = 0.5;
            } else {
              normalizedX = value / selectedRows;
            }
            
            const maxX = width;
            const x = normalizedX * maxX;
            const y = (idx + 1) * rowHeight;
            
            ballEl.style.left = `${boardPadding + x - ballSize / 2}px`;
            ballEl.style.top = `${boardPadding + y - ballSize / 2}px`;
            ballEl.style.transition = `left ${duration}ms cubic-bezier(0.4, 0, 0.2, 1), top ${duration}ms cubic-bezier(0.4, 0, 0.2, 1)`;
            
            if (idx === path.length - 1) {
              setTimeout(() => {
                highlightSlot(bucketIndex);
                setTimeout(() => {
                  ballEl.remove();
                  resolve();
                }, 500);
              }, duration);
            }
          }, delay + idx * duration);
        });
      });
    }

    function clearAllBalls() {
      if (ballsContainer) {
        ballsContainer.innerHTML = '';
      }
      highlightedSlot = null;
      Array.from(payoutsEl.children).forEach((slot) => slot.classList.remove('highlight'));
    }

    async function loadHistory() {
      try {
        const resp = await fetch(`${BASE_URL}/plinko/history`, { credentials: 'include' });
        if (!resp.ok) return;
        const data = await resp.json();
        renderHistory(data);
      } catch (err) {
        console.error('plinko history error', err);
      }
    }

    function renderHistory(entries) {
      historyList.innerHTML = '';
      if (!Array.isArray(entries) || !entries.length) {
        historyList.innerHTML = '<div class="history-item muted">–ò—Å—Ç–æ—Ä–∏—è –ø–æ—è–≤–∏—Ç—Å—è –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–π –∏–≥—Ä—ã</div>';
        return;
      }
      entries.forEach((entry) => {
        const card = document.createElement('div');
        card.className = 'history-item';
        const date = new Date(entry.timestamp);
        const header = document.createElement('div');
        header.innerHTML = `<strong>${date.toLocaleTimeString('ru-RU')}</strong> ‚Äî ${entry.rows} —Ä—è–¥–æ–≤`;
        const body = document.createElement('div');
        body.className = 'muted';
        const net = (entry.payout || 0) - (entry.bet || 0);
        body.textContent = [
          `–†–∏—Å–∫: ${riskTitles[entry.risk] || entry.risk}`,
          `–°—Ç–∞–≤–∫–∞ ${formatCandy(entry.bet)}`,
          `x${Number(entry.multiplier || 0).toFixed(2)} ‚Üí ${formatSignedCandy(net)}`
        ].join(' ¬∑ ');
        card.appendChild(header);
        card.appendChild(body);
        historyList.appendChild(card);
      });
    }

    init();
  </script>
</body>
</html>

