<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css" />
  <title>–ö—Ä–∞—à ¬∑ 320xbet</title>
</head>
<body>
  <div class="game-page">
    <header class="glass-card top-bar">
      <div>
        <p class="eyebrow">–†–µ–∂–∏–º</p>
        <h1>üöÄ –ì–ª–æ–±–∞–ª—å–Ω—ã–π –∫—Ä–∞—à</h1>
        <p class="muted">–°—Ç–∞–≤—å –∫–æ–Ω—Ñ–µ—Ç–∫–∏, —Å–ª–µ–¥–∏ –∑–∞ —Ä–æ—Å—Ç–æ–º –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ –∏ –∑–∞–±–∏—Ä–∞–π –Ω–∞–≥—Ä–∞–¥—É –¥–æ –≤–∑—Ä—ã–≤–∞.</p>
      </div>
      <button class="btn-outline" onclick="window.location.href='mainPage.html'">‚¨Ö –ù–∞–∑–∞–¥</button>
    </header>

    <section class="crash-layout">
      <article class="glass-card crash-panel">
        <div class="balance-pill">
          –ë–∞–ª–∞–Ω—Å: <span id="balance">...</span> üç¨
        </div>

        <label for="bet" class="muted">–†–∞–∑–º–µ—Ä —Å—Ç–∞–≤–∫–∏</label>
        <input type="number" id="bet" min="1" class="input-field" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å—Ç–∞–≤–∫—É" />
        <label for="autoCashout" class="muted">–ê–≤—Ç–æ–≤—ã–≤–æ–¥ –Ω–∞ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</label>
        <input type="number" id="autoCashout" min="1" step="0.01" class="input-field" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: 2.00" />
        <button id="actionBtn" class="start">–ü–æ—Å—Ç–∞–≤–∏—Ç—å</button>

        <div>
          <p class="muted">–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç</p>
          <h2><span id="coefficient">1.00</span>x</h2>
        </div>

        <p id="message" class="message"></p>

        <div class="chart-wrapper">
          <div class="link-row" style="justify-content: space-between;">
            <p class="muted" style="margin:0">–ì—Ä–∞—Ñ–∏–∫ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞</p>
            <span class="pill">–ü—Ä–æ–≥–Ω–æ–∑ –¥–æ –∫—Ä–∞—à–∞</span>
          </div>
          <canvas id="coefChart" height="180"></canvas>
        </div>

        <div>
          <p class="muted">–£—á–∞—Å—Ç–Ω–∏–∫–∏ —Ä–∞—É–Ω–¥–∞</p>
          <div id="playersContainer" class="players-list"></div>
        </div>
      </article>

      <article class="glass-card history-card">
        <p class="eyebrow">–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã</p>
        <div id="historyList" class="history-list"></div>
      </article>
    </section>
  </div>

  <div id="historyModal" class="modal-overlay hidden">
    <div class="modal-content glass-card">
      <button id="historyModalClose" class="modal-close" aria-label="–ó–∞–∫—Ä—ã—Ç—å">‚úï</button>
      <div id="historyModalBody"></div>
    </div>
  </div>

<script>
  const BASE_URL = 'https://fen4yaragithubio-production.up.railway.app';

  const BASE_SPEED = 0.05; // —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω —Å —Å–µ—Ä–≤–µ—Ä–æ–º
  const ACCEL = 0.08;
  const MAX_CHART_POINTS = 240;
  const LOG_SCALE_THRESHOLD = 6; // –ø–µ—Ä–µ—Ö–æ–¥ –Ω–∞ –ª–æ–≥-—à–∫–∞–ª—É, –µ—Å–ª–∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –æ–≥—Ä–æ–º–Ω—ã–π

  let user = null;
  let animationFrameId = null;
  let stateIntervalId = null;
  let serverOffset = 0;
  let coefHistory = [];
  let currentPhase = 'idle';

  const balanceEl = document.getElementById('balance');
  const coefficientEl = document.getElementById('coefficient');
  const messageEl = document.getElementById('message');
  const actionBtn = document.getElementById('actionBtn');
  const betInputEl = document.getElementById('bet');
  const autoCashoutEl = document.getElementById('autoCashout');
  const playersContainer = document.getElementById('playersContainer');
  const historyList = document.getElementById('historyList');
  const historyModal = document.getElementById('historyModal');
  const historyModalClose = document.getElementById('historyModalClose');
  const historyModalBody = document.getElementById('historyModalBody');
  const chartCanvas = document.getElementById('coefChart');
  const chartCtx = chartCanvas ? chartCanvas.getContext('2d') : null;

  let bettingEndTime = null;
  let crashTime = null;
  let crashEnded = true;
  let hasBet = false;
  let hasCashedOut = false;
  let autoCashoutTarget = null;
  let lastBet = 0;
  let cachedCrashHistory = [];

  window.addEventListener('DOMContentLoaded', async () => {
    resizeChart();
    window.addEventListener('resize', resizeChart);
    try {
      const resp = await fetch(`${BASE_URL}/check-auth`, { credentials: 'include' });
      if (!resp.ok) throw new Error('–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω');
      user = await resp.json();
      balanceEl.textContent = user.balance;

      // –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è UI
      actionBtn.disabled = false;
      actionBtn.textContent = '–ü–æ—Å—Ç–∞–≤–∏—Ç—å';
      actionBtn.classList.add('start');

      await fetchCrashState();
      await loadHistory();
      stateIntervalId = setInterval(fetchCrashState, 500);
    } catch (err) {
      alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –≤–æ–π–¥–∏—Ç–µ.');
      window.location.href = 'index.html';
    }
  });

  function showMessage(msg, color = '#333') {
    messageEl.textContent = msg;
    messageEl.style.color = color;
  }

  function renderPlayers(players) {
    playersContainer.innerHTML = '';
    (players || []).forEach((p) => {
      const div = document.createElement('div');
      div.className = 'player-row';
      const colorDot = document.createElement('span');
      colorDot.className = 'player-color';
      colorDot.style.background = p.color || '#888';
      const text = document.createElement('span');
      text.textContent = `${p.username} ‚Äî ${p.bet} üç¨`;
      if (p.cashedOut) {
        text.textContent += ` ‚Üí –∑–∞–±—Ä–∞–ª(–∞) x${(p.cashoutCoef||0).toFixed(2)} (–≤—ã–∏–≥—Ä—ã—à ${p.winnings} üç¨)`;
      }
      div.append(colorDot, text);
      playersContainer.append(div);
    });
  }

  // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
  async function fetchCrashState() {
    try {
      const resp = await fetch(`${BASE_URL}/crash/state`, { credentials: 'include' });
      const data = await resp.json();
      if (!resp.ok) throw new Error(data.error || '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è');

      // —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –≤—Ä–µ–º—è –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞
      const now = data.serverTime || Date.now();
      serverOffset = now - Date.now();
      const players = data.players || [];
      renderPlayers(players);
      bettingEndTime = data.bettingEndTime;
      crashTime = data.crashTime;
      crashEnded = data.ended;
      if (user) {
        const me = players.find((p) => p.username === user.username);
        if (me) {
          hasBet = true;
          hasCashedOut = !!me.cashedOut;
        } else {
          hasBet = false;
          hasCashedOut = false;
        }
      }
      const nextPhase = data.ended
        ? 'idle'
        : now < bettingEndTime
          ? 'betting'
          : 'running';
      handlePhaseTransition(nextPhase, data);

      // –ï—Å–ª–∏ —Ä–∞—É–Ω–¥ –Ω–µ –∏–¥—ë—Ç (ended = true) ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç (–µ—Å–ª–∏ –µ—Å—Ç—å) –∏ –æ—Ç–∫—Ä—ã–≤–∞–µ–º —Å—Ç–∞–≤–∫–∏
      if (data.ended) {
        stopCoefficientAnimation();
        if (data.crashPoint != null) {
          coefficientEl.textContent = data.crashPoint.toFixed(2);
          showMessage('üí• –ö—Ä–∞—à! –ñ–¥—ë–º –Ω–æ–≤–æ–≥–æ —Ä–∞—É–Ω–¥–∞', 'red');
        } else {
          coefficientEl.textContent = '1.00';
          showMessage('–ñ–¥—ë–º –Ω–æ–≤–æ–≥–æ —Ä–∞—É–Ω–¥–∞', '#333');
        }
        betInputEl.disabled = false;
        hasBet = false;
        hasCashedOut = false;
        autoCashoutTarget = null;
        if (lastBet > 0) {
          betInputEl.value = lastBet;
        }
        actionBtn.disabled = false;
        actionBtn.textContent = '–ü–æ—Å—Ç–∞–≤–∏—Ç—å';
        actionBtn.classList.remove('cashout');
        actionBtn.classList.add('start');
        if (chartCtx && coefHistory.length === 0) {
          resetChart(1);
        }
        await loadHistory();
        return;
      }

      // –§–∞–∑–∞ —Å—Ç–∞–≤–æ–∫ (—Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è < bettingEndTime) ‚Äî —Å—Ç–∞–≤–∫–∏ –û–¢–ö–†–´–¢–´
      if (now < bettingEndTime) {
        stopCoefficientAnimation();
        coefficientEl.textContent = '1.00';
        const secsLeft = Math.ceil((bettingEndTime - now) / 1000);
        showMessage(`–§–∞–∑–∞ —Å—Ç–∞–≤–æ–∫, –µ—â—ë ${secsLeft} —Å–µ–∫`, '#333');
        betInputEl.disabled = false;
        actionBtn.disabled = false;
        actionBtn.textContent = hasBet ? '–î–æ–±–∞–≤–∏—Ç—å —Å—Ç–∞–≤–∫—É' : '–ü–æ—Å—Ç–∞–≤–∏—Ç—å';
        actionBtn.classList.remove('cashout');
        actionBtn.classList.add('start');
        return;
      }

      // –§–∞–∑–∞ —Ä–æ—Å—Ç–∞ (bettingEndTime ‚â§ now < crashTime)
      if (now >= bettingEndTime && now < crashTime) {
        betInputEl.disabled = true;
        // –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ—Å—Ç–∞–≤–∏–ª ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É "–ó–∞–±—Ä–∞—Ç—å"
        if (hasBet && !hasCashedOut) {
          actionBtn.disabled = false;
          actionBtn.textContent = '–ó–∞–±—Ä–∞—Ç—å';
          actionBtn.classList.remove('start');
          actionBtn.classList.add('cashout');
        } else {
          actionBtn.disabled = true; // –Ω–µ–ª—å–∑—è –∑–∞–±—Ä–∞—Ç—å –µ—Å–ª–∏ –Ω–µ —Å—Ç–∞–≤–∏–ª
          actionBtn.textContent = hasBet ? '–ó–∞–±—Ä–∞—Ç—å' : '–°—Ç–∞–≤–∫–∞ –Ω–µ —Å–æ–≤–µ—Ä—à–µ–Ω–∞';
          actionBtn.classList.remove('start');
          actionBtn.classList.add('cashout');
        }
        showMessage('–†–∞—É–Ω–¥ –∏–¥—ë—Ç... üöÄ', '#333');
        // –∑–∞–ø—É—Å—Ç–∏—Ç—å –æ—Ç—Ä–∏—Å–æ–≤–∫—É –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞
        startCoefficientAnimation();
        return;
      }

      // –ï—Å–ª–∏ now >= crashTime ‚Äî —Å—Ä–∞–∑—É –æ–±—Ä–∞–±–æ—Ç–∞–µ–º –∫—Ä–∞—à (–∏–Ω–æ–≥–¥–∞ —Å–µ—Ä–≤–µ—Ä –µ—â—ë –æ–±–Ω–æ–≤–ª—è–µ—Ç)
      if (now >= crashTime) {
        stopCoefficientAnimation();
        if (data.crashPoint != null) {
          coefficientEl.textContent = data.crashPoint.toFixed(2);
          showMessage('üí• –ö—Ä–∞—à! –í—ã–∏–≥—Ä–∞—Ç—å —É–∂–µ –Ω–µ–ª—å–∑—è.', 'red');
        } else {
          coefficientEl.textContent = '1.00';
          showMessage('–ñ–¥—ë–º –Ω–æ–≤–æ–≥–æ —Ä–∞—É–Ω–¥–∞', '#333');
        }
        betInputEl.disabled = false;
        hasBet = false;
        hasCashedOut = false;
        actionBtn.disabled = false;
        actionBtn.textContent = '–ü–æ—Å—Ç–∞–≤–∏—Ç—å';
        actionBtn.classList.remove('cashout');
        actionBtn.classList.add('start');
        await updateBalanceInUI();
        await loadHistory();
      }
    } catch (err) {
      console.error(err);
      showMessage(err.message || '–û—à–∏–±–∫–∞', 'red');
    }
  }

  function handlePhaseTransition(nextPhase, state) {
    if (currentPhase === nextPhase) return;
    currentPhase = nextPhase;
    if (nextPhase === 'betting') {
      resetChart(1);
      stopCoefficientAnimation();
    } else if (nextPhase === 'running') {
      if (!coefHistory.length && bettingEndTime) {
        pushCoefHistory(bettingEndTime, 1);
      }
      startCoefficientAnimation();
    } else if (nextPhase === 'idle') {
      stopCoefficientAnimation();
      if (state.crashPoint != null) {
        pushCoefHistory(state.crashTime || (Date.now() + serverOffset), state.crashPoint);
        drawChart();
      }
    }
  }

  function startCoefficientAnimation() {
    if (animationFrameId || !bettingEndTime || !crashTime) return;
    animationFrameId = requestAnimationFrame(animationTick);
  }

  function stopCoefficientAnimation() {
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }
  }

  function animationTick() {
    if (!bettingEndTime || !crashTime) {
      animationFrameId = null;
      return;
    }
    const serverNow = Date.now() + serverOffset;
    if (serverNow >= crashTime || crashEnded) {
      animationFrameId = null;
      return;
    }
    const elapsedSec = Math.max(0, (serverNow - bettingEndTime) / 1000);
    const coef = 1 + BASE_SPEED * elapsedSec + 0.5 * ACCEL * elapsedSec * elapsedSec;
    coefficientEl.textContent = coef.toFixed(2);
    
    // –ê–≤—Ç–æ–≤—ã–≤–æ–¥
    if (autoCashoutTarget && hasBet && !hasCashedOut && coef >= autoCashoutTarget) {
      handleCashout();
      return;
    }
    
    if (chartCtx) {
      pushCoefHistory(serverNow, coef);
      drawChart();
    }
    animationFrameId = requestAnimationFrame(animationTick);
  }

  function pushCoefHistory(time, value) {
    if (!chartCtx) return;
    coefHistory.push({ time, value });
    if (coefHistory.length > MAX_CHART_POINTS) {
      coefHistory.shift();
    }
  }

  function resetChart(initialValue = 1) {
    if (!chartCtx) return;
    coefHistory = [];
    const baseTime = bettingEndTime || (Date.now() + serverOffset);
    pushCoefHistory(baseTime, initialValue);
    drawChart();
  }

  function drawChart() {
    if (!chartCtx || !coefHistory.length) return;
    chartCtx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);

    const startTime = coefHistory[0].time;
    const latestTime = coefHistory[coefHistory.length - 1].time;
    const duration = Math.max(1000, latestTime - startTime);
    const projectionSpan = crashTime
      ? Math.max(duration, crashTime - startTime)
      : duration;

    const values = coefHistory.map((p) => p.value);
    let minVal = Math.min(1, ...values);
    let maxVal = Math.max(...values);
    if (maxVal - minVal < 0.25) {
      maxVal = minVal + 0.25;
    } else {
      maxVal *= 1.05;
    }
    const useLogScale = maxVal / Math.max(minVal, 1) >= LOG_SCALE_THRESHOLD;
    let minLog = null;
    let maxLog = null;
    if (useLogScale) {
      minVal = Math.max(minVal, 1.0001);
      minLog = Math.log(minVal);
      maxLog = Math.log(maxVal);
    }

    const normalize = (value) => {
      if (useLogScale) {
        const safe = Math.max(value, 1.0001);
        return (Math.log(safe) - minLog) / Math.max(0.0001, maxLog - minLog);
      }
      return (value - minVal) / Math.max(0.0001, maxVal - minVal);
    };

    // grid
    chartCtx.strokeStyle = 'rgba(255, 255, 255, 0.07)';
    chartCtx.lineWidth = 1;
    for (let i = 0; i <= 4; i++) {
      const y = (chartCanvas.height / 4) * i;
      chartCtx.beginPath();
      chartCtx.moveTo(0, y);
      chartCtx.lineTo(chartCanvas.width, y);
      chartCtx.stroke();
    }

    const points = coefHistory.map((point) => {
      const x = ((point.time - startTime) / duration) * chartCanvas.width;
      const norm = normalize(point.value);
      const y = chartCanvas.height - norm * chartCanvas.height;
      return { x, y };
    });

    // area
    chartCtx.beginPath();
    points.forEach((pt, idx) => {
      if (idx === 0) chartCtx.moveTo(pt.x, pt.y);
      else chartCtx.lineTo(pt.x, pt.y);
    });
    chartCtx.lineTo(points[points.length - 1].x, chartCanvas.height);
    chartCtx.lineTo(points[0].x, chartCanvas.height);
    chartCtx.closePath();
    chartCtx.fillStyle = 'rgba(127, 90, 240, 0.12)';
    chartCtx.fill();

    // line
    chartCtx.beginPath();
    points.forEach((pt, idx) => {
      if (idx === 0) chartCtx.moveTo(pt.x, pt.y);
      else chartCtx.lineTo(pt.x, pt.y);
    });
    chartCtx.strokeStyle = '#7f5af0';
    chartCtx.lineWidth = 2;
    chartCtx.stroke();

    // projection
    if (currentPhase === 'running' && crashTime && bettingEndTime) {
      const projectionPoints = [];
      const steps = 30;
      const startProjection = Math.max(points[points.length - 1].x, 0);
      for (let i = 0; i <= steps; i++) {
        const t = bettingEndTime + ((crashTime - bettingEndTime) * (i / steps));
        const rawX = ((t - startTime) / projectionSpan) * chartCanvas.width;
        const x = Math.min(chartCanvas.width, rawX);
        if (x < startProjection) continue;
        const elapsed = Math.max(0, (t - bettingEndTime) / 1000);
        const projectedValue = 1 + BASE_SPEED * elapsed + 0.5 * ACCEL * elapsed * elapsed;
        const norm = normalize(projectedValue);
        const y = chartCanvas.height - norm * chartCanvas.height;
        projectionPoints.push({ x, y });
      }
      if (projectionPoints.length > 1) {
        chartCtx.save();
        chartCtx.setLineDash([6, 6]);
        chartCtx.beginPath();
        projectionPoints.forEach((pt, idx) => {
          if (idx === 0) chartCtx.moveTo(pt.x, pt.y);
          else chartCtx.lineTo(pt.x, pt.y);
        });
        chartCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        chartCtx.lineWidth = 1.5;
        chartCtx.stroke();
        chartCtx.restore();
      }
    }
  }

  function resizeChart() {
    if (!chartCanvas) return;
    const width = chartCanvas.parentElement ? chartCanvas.parentElement.clientWidth : chartCanvas.clientWidth;
    chartCanvas.width = width;
    chartCanvas.height = 180;
    drawChart();
  }

  async function updateBalanceInUI() {
    try {
      const resp = await fetch(`${BASE_URL}/check-auth`, { credentials: 'include' });
      if (!resp.ok) throw new Error('–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω');
      user = await resp.json();
      balanceEl.textContent = user.balance;
    } catch {
      // –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
    }
  }

  actionBtn.addEventListener('click', async () => {
    if (actionBtn.classList.contains('cashout')) {
      await handleCashout();
    } else {
      await handleBet();
    }
  });

  async function handleBet() {
    const betValue = parseInt(betInputEl.value, 10);
    if (!betValue || betValue <= 0) {
      showMessage('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Ç–∞–≤–∫–∞!', 'red');
      return;
    }
    if (betValue > user.balance) {
      showMessage('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!', 'red');
      return;
    }
    if (bettingEndTime && Date.now() + serverOffset > bettingEndTime) {
      showMessage('–§–∞–∑–∞ —Å—Ç–∞–≤–æ–∫ –∑–∞–∫—Ä—ã—Ç–∞', 'red');
      return;
    }

    try {
      actionBtn.disabled = true;
      const resp = await fetch(`${BASE_URL}/crash/join`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ bet: betValue })
      });
      const data = await resp.json();
      if (!resp.ok) throw new Error(data.error || '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å—Ç–∞–≤–∫–µ');

      user.balance -= betValue;
      balanceEl.textContent = user.balance;

      renderPlayers(data.players || []);
      bettingEndTime = data.bettingEndTime;
      crashTime = data.crashTime;
      crashEnded = data.ended;
      hasBet = true;
      hasCashedOut = false;
      lastBet = betValue;
      autoCashoutTarget = autoCashoutEl.value ? parseFloat(autoCashoutEl.value) : null;
      betInputEl.value = betValue;

      const now = Date.now() + serverOffset;
      if (now < bettingEndTime) {
        actionBtn.textContent = '–î–æ–±–∞–≤–∏—Ç—å —Å—Ç–∞–≤–∫—É';
        actionBtn.classList.remove('cashout');
        actionBtn.classList.add('start');
        actionBtn.disabled = false;
        const secsLeft = Math.ceil((bettingEndTime - now) / 1000);
        showMessage(`–§–∞–∑–∞ —Å—Ç–∞–≤–æ–∫, –µ—â—ë ${secsLeft} —Å–µ–∫`, '#333');
      } else {
        actionBtn.textContent = '–ó–∞–±—Ä–∞—Ç—å';
        actionBtn.classList.remove('start');
        actionBtn.classList.add('cashout');
        actionBtn.disabled = false;
        showMessage('–†–∞—É–Ω–¥ –∏–¥—ë—Ç... üöÄ', '#333');
        startCoefficientAnimation();
      }
    } catch (err) {
      showMessage(err.message || '–û—à–∏–±–∫–∞', 'red');
      actionBtn.disabled = false;
    }
  }

  async function handleCashout() {
    if (!hasBet || hasCashedOut) return;
    hasCashedOut = true;
    actionBtn.disabled = true;
    const coefToTake = parseFloat(coefficientEl.textContent) || 1.0;
    try {
      const resp = await fetch(`${BASE_URL}/crash/cashout`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ coefficient: coefToTake })
      });
      const data = await resp.json();
      if (!resp.ok) throw new Error(data.error || '–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–ª–∞—Ç–µ');

      showMessage(`‚úÖ –í—ã –∑–∞–±—Ä–∞–ª–∏ ${data.winnings} üç¨ (x${coefToTake.toFixed(2)})`, 'green');
      user.balance = data.newBalance;
      balanceEl.textContent = user.balance;

      const state = await fetch(`${BASE_URL}/crash/state`, { credentials: 'include' });
      const stData = await state.json();
      renderPlayers(stData.players || []);
    } catch (err) {
      showMessage(err.message || '–û—à–∏–±–∫–∞', 'red');
      hasCashedOut = false;
      actionBtn.disabled = false;
    }
  }

  async function loadHistory() {
    try {
      const resp = await fetch(`${BASE_URL}/crash/history`, { credentials: 'include' });
      const data = await resp.json();
      if (!resp.ok) throw new Error(data.error || '–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏—Å—Ç–æ—Ä–∏–∏');

      cachedCrashHistory = data;
      historyList.innerHTML = '';
      data.forEach((round) => {
        const li = document.createElement('li');
        li.className = 'history-item clickable';
        const date = new Date(round.timestamp);
        const header = document.createElement('div');
        header.innerHTML = `<strong>${date.toLocaleString('ru-RU')}</strong> ‚Üí x${round.crashPoint.toFixed(2)}, –ø—É–ª ${round.totalBet}üç¨`;
        li.append(header);

        const subUl = document.createElement('ul');
        subUl.className = 'history-players';
        round.players.forEach((p) => {
          const subLi = document.createElement('li');
          let txt = `${p.username} ‚Äî —Å—Ç–∞–≤–∫–∞ ${p.bet}üç¨`;
          if (p.cashedOut) {
            txt += `, –∑–∞–±—Ä–∞–ª(–∞) –Ω–∞ x${p.cashoutCoef.toFixed(2)} ‚Üí –≤—ã–∏–≥—Ä—ã—à ${p.winnings}üç¨`;
          } else {
            txt += `, –ø—Ä–æ–∏–≥—Ä–∞–ª(–∞)`;
          }
          subLi.textContent = txt;
          subUl.append(subLi);
        });
        li.append(subUl);
        li.addEventListener('click', () => openCrashHistoryModal(round));
        historyList.append(li);
      });
    } catch (err) {
      console.error(err);
    }
  }

  function openCrashHistoryModal(round) {
    if (!historyModal || !historyModalBody) return;
    const date = new Date(round.timestamp).toLocaleString('ru-RU');
    const playersList = (round.players || [])
      .map((p) => {
        const status = p.cashedOut
          ? `–∑–∞–±—Ä–∞–ª x${p.cashoutCoef?.toFixed(2) || '‚Äî'} ‚Üí ${p.winnings}üç¨`
          : '–ø—Ä–æ–∏–≥—Ä–∞–ª';
        return `<li><strong>${p.username}</strong> ‚Äî —Å—Ç–∞–≤–∫–∞ ${p.bet}üç¨, ${status}</li>`;
      })
      .join('');

    historyModalBody.innerHTML = `
      <p class="muted">${date}</p>
      <h2>–ö—Ä–∞—à x${round.crashPoint.toFixed(2)}</h2>
      <p>–ü—É–ª: ${round.totalBet} üç¨</p>
      <ul class="history-players highlight">${playersList || '<li>–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</li>'}</ul>
    `;
    historyModal.classList.remove('hidden');
  }

  function closeHistoryModal() {
    if (historyModal) {
      historyModal.classList.add('hidden');
    }
  }

  historyModalClose?.addEventListener('click', closeHistoryModal);
  historyModal?.addEventListener('click', (e) => {
    if (e.target === historyModal) closeHistoryModal();
  });
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closeHistoryModal();
  });
</script>
</body>
</html>
