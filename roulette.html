<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>üé° –†—É–ª–µ—Ç–∫–∞</title>
<link rel="stylesheet" href="style.css" />
<style>
  .wheel {
    width: 300px;
    height: 300px;
    border-radius: 50%;
    border: 10px solid #333;
    margin: 20px auto;
    position: relative;
    overflow: hidden;
  }
  .wheel canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
  .pointer {
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 20px solid transparent;
    border-right: 20px solid transparent;
    border-bottom: 30px solid red;
  }
  #message {
    font-weight: bold;
    margin-top: 10px;
    color: #333;
    text-align: center;
  }
  #countdown {
    font-size: 1rem;
    color: #555;
    text-align: center;
    margin-top: 5px;
  }
  #legend {
    max-width: 300px;
    margin: 10px auto;
    font-size: 0.9rem;
  }
  .legend-item {
    display: flex;
    align-items: center;
    margin-bottom: 4px;
  }
  .legend-color {
    width: 16px;
    height: 16px;
    border: 1px solid #000;
    margin-right: 8px;
  }
</style>
</head>
<body>
<main>
<h1>üé° –†—É–ª–µ—Ç–∫–∞</h1>
<p>–ë–∞–ª–∞–Ω—Å: <span id="balance">...</span> üç¨</p>

<div>
  <label for="bet">–°—Ç–∞–≤–∫–∞:</label>
  <input type="number" id="bet" min="1" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å—Ç–∞–≤–∫—É" />
  <button id="joinBtn">–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è</button>
</div>
<div id="countdown">–î–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–ø–∏–Ω–∞: <span id="timer">‚Äî</span> —Å–µ–∫</div>

<div class="wheel">
  <canvas id="canvas" width="300" height="300"></canvas>
  <div class="pointer"></div>
</div>

<div id="legend"></div>
<p id="message"></p>
<button onclick="window.location.href='mainPage.html'">‚¨ÖÔ∏è –ù–∞–∑–∞–¥</button>
</main>

<script>
const BASE_URL = 'https://fen4yaragithubio-production-9286.up.railway.app';

let user = null;
let players = [];
let spinPlayers = [];
let isAnimating = false;
let nextSpinTimestamp = null;

const balanceEl = document.getElementById('balance');
const messageEl = document.getElementById('message');
const joinBtn = document.getElementById('joinBtn');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const timerEl = document.getElementById('timer');
const legendEl = document.getElementById('legend');

function easeOut(t) {
  return 1 - Math.pow(1 - t, 3);
}

function showMessage(msg, color = '#333') {
  messageEl.textContent = msg;
  messageEl.style.color = color;
}

function drawWheelByList(list) {
  ctx.clearRect(0, 0, 300, 300);
  if (list.length === 0) return;
  const totalBet = list.reduce((s, p) => s + p.bet, 0);
  let startAngle = 0;
  list.forEach(p => {
    const angle = (p.bet / totalBet) * 2 * Math.PI;
    ctx.beginPath();
    ctx.moveTo(150, 150);
    ctx.arc(150, 150, 150, startAngle, startAngle + angle);
    ctx.fillStyle = p.color;
    ctx.fill();
    startAngle += angle;
  });
  renderLegend(list);
}

function renderLegend(list) {
  legendEl.innerHTML = '';
  list.forEach(p => {
    const item = document.createElement('div');
    item.className = 'legend-item';
    const colorBox = document.createElement('div');
    colorBox.className = 'legend-color';
    colorBox.style.backgroundColor = p.color;
    const text = document.createElement('div');
    text.textContent = `${p.username}: ${p.bet} üç¨`;
    item.appendChild(colorBox);
    item.appendChild(text);
    legendEl.appendChild(item);
  });
}


async function fetchPlayersAndDraw() {
  try {
    const resp = await fetch(`${BASE_URL}/roulette/players`, { credentials: 'include' });
    if (!resp.ok) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–≥—Ä–æ–∫–æ–≤');
    const data = await resp.json();
    players = data.players;

    if (players.length < 2) {
      showMessage('–ñ–¥—ë–º –º–∏–Ω–∏–º—É–º 2 –∏–≥—Ä–æ–∫–∞ –¥–ª—è –∑–∞–ø—É—Å–∫–∞ —Å–ø–∏–Ω–∞', 'orange');
      timerEl.textContent = '‚Äî';
      return;
    } else {
      showMessage('');
    }

    if (!isAnimating) drawWheelByList(players);
  } catch (err) {
    console.error('fetchPlayersAndDraw:', err);
  }
}

function startCountdown() {
  if (!nextSpinTimestamp) {
    timerEl.textContent = '‚Äî';
    return;
  }
  function updateTimer() {
    const now = Date.now();
    let diff = Math.floor((nextSpinTimestamp - now) / 1000);
    if (diff < 0) diff = 0;
    timerEl.textContent = diff;
  }
  updateTimer();
  const intervalId = setInterval(() => {
    updateTimer();
    if (Date.now() >= nextSpinTimestamp) {
      clearInterval(intervalId);
      scheduleSpinAnimation();
    }
  }, 500);
}



async function fetchNextSpin() {
  try {
    const resp = await fetch(`${BASE_URL}/roulette/next-spin`, { credentials: 'include' });
    if (!resp.ok) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å next-spin');
    const data = await resp.json();
    nextSpinTimestamp = data.nextSpin;
    startCountdown();
  } catch (err) {
    console.error('fetchNextSpin:', err);
  }
}

function scheduleSpinAnimation() {
  if (isAnimating || nextSpinTimestamp === null) return;
  const now = Date.now();
  const delay = nextSpinTimestamp - now;
  if (delay <= 0) {
    animateSpin();
  } else {
    setTimeout(animateSpin, delay);
  }
}

function animateSpin() {
  if (isAnimating) return;

  spinPlayers = players.slice();

  if (spinPlayers.length < 2) {
    showMessage('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∏–≥—Ä–æ–∫–æ–≤ –¥–ª—è —Å–ø–∏–Ω–∞.', 'orange');
    isAnimating = false;
    fetchNextSpin();
    return;
  }

  isAnimating = true;
  showMessage('–ö—Ä—É—Ç–∏–º...');

  // 1. –ü–æ–ª—É—á–∞–µ–º –ø–æ–±–µ–¥–∏—Ç–µ–ª—è —Å —Å–µ—Ä–≤–µ—Ä–∞ (–∑–∞–ø—Ä–æ—Å –∑–∞—Ä–∞–Ω–µ–µ –Ω–µ –¥–µ–ª–∞–µ–º, –∞ –≤ –∫–æ–Ω—Ü–µ –∞–Ω–∏–º–∞—Ü–∏–∏)
  // –ü–æ–∫–∞ –ø—Ä–æ–∫—Ä—É—á–∏–≤–∞–µ–º –∫–æ–ª–µ—Å–æ —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π

  let angleOffset = 0;  // –ß—Ç–æ–±—ã –∞–∫–∫—É–º—É–ª–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç

  const spinTime = 4000;  // –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏–∏, –º–æ–∂–Ω–æ —É–≤–µ–ª–∏—á–∏—Ç—å

  const startTime = performance.now();

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞ —É–≥–ª–∞ –Ω–∞—á–∞–ª–∞ —Å–µ–∫—Ç–æ—Ä–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
  function getWinnerAngle(winnerName) {
    const totalBet = spinPlayers.reduce((s, p) => s + p.bet, 0);
    let startAngle = 0;
    for (const p of spinPlayers) {
      const angle = (p.bet / totalBet) * 2 * Math.PI;
      if (p.username === winnerName) {
        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–µ—Ä–µ–¥–∏–Ω—É —Å–µ–∫—Ç–æ—Ä–∞, —á—Ç–æ–±—ã —Å—Ç—Ä–µ–ª–∫–∞ —É–∫–∞–∑—ã–≤–∞–ª–∞ –ø–æ —Ü–µ–Ω—Ç—Ä—É —Å–µ–∫—Ç–æ—Ä–∞
        return startAngle + angle / 2;
      }
      startAngle += angle;
    }
    return 0; // –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
  }

  function frame(now) {
    const progress = now - startTime;
    const frac = Math.min(progress / spinTime, 1);

    // easeOut –¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏
    const easedFrac = easeOut(frac);

    // –ü–æ–∫–∞ –Ω–µ –∑–Ω–∞–µ–º –ø–æ–±–µ–¥–∏—Ç–µ–ª—è, –≤—Ä–∞—â–∞–µ–º –∫–æ–ª–µ—Å–æ –ø—Ä–æ—Å—Ç–æ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –æ–±–æ—Ä–æ—Ç–æ–≤
    let rotate;

    if (frac < 1) {
      rotate = easedFrac * 10 * Math.PI;  // 5 –æ–±–æ—Ä–æ—Ç–æ–≤ (10 PI = 5 –∫—Ä—É–≥–æ–≤)
      ctx.save();
      ctx.clearRect(0, 0, 300, 300);
      ctx.translate(150, 150);
      ctx.rotate(rotate + angleOffset);
      ctx.translate(-150, -150);
      drawWheelByList(spinPlayers);
      ctx.restore();
      requestAnimationFrame(frame);
    } else {
      // –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å ‚Äî –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –ø–æ–±–µ–¥–∏—Ç–µ–ª—è —Å —Å–µ—Ä–≤–µ—Ä–∞
      fetch(`${BASE_URL}/roulette/result`, { credentials: 'include' })
        .then(r => {
          if (!r.ok) throw new Error('–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞');
          return r.json();
        })
        .then(resData => {
          const winnerName = resData.winner;
          const totalPool = spinPlayers.reduce((s, p) => s + p.bet, 0);
          const commission = Math.floor(totalPool * 0.08);
          const winnings = totalPool - commission;

          // –¢–µ–ø–µ—Ä—å –ø–ª–∞–≤–Ω–æ –¥–æ–∫—Ä—É—Ç–∏—Ç—å –∫–æ–ª–µ—Å–æ –¥–æ —Å–µ–∫—Ç–æ—Ä–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
          const winnerAngle = getWinnerAngle(winnerName);

          // –†–∞—Å—Å—á–∏—Ç–∞–µ–º –Ω—É–∂–Ω—ã–π —É–≥–æ–ª –≤—Ä–∞—â–µ–Ω–∏—è (–∫–æ—Ç–æ—Ä—ã–π —Å—Ç–∞–≤–∏—Ç –ø–æ–±–µ–¥–∏—Ç–µ–ª—è –ø–æ–¥ —Å—Ç—Ä–µ–ª–∫—É)
          // –°—Ç—Ä–µ–ª–∫–∞ —É –Ω–∞—Å —Å–≤–µ—Ä—Ö—É (–Ω–∞ 12 —á–∞—Å–æ–≤), –∞ 0 —É–≥–ª–∞ –≤ canvas ‚Äî –Ω–∞ 3 —á–∞—Å–∞ (–ø—Ä–∞–≤–æ),
          // —Ç–∞–∫ —á—Ç–æ —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º:
          const pointerAngle = -Math.PI / 2;  // —Å—Ç—Ä–µ–ª–∫–∞ –Ω–∞ 12 —á–∞—Å–æ–≤ ‚Äî -90 –≥—Ä–∞–¥—É—Å–æ–≤

          // –ù—É–∂–Ω–æ –ø–æ–≤–µ—Ä–Ω—É—Ç—å –∫–æ–ª–µ—Å–æ —Ç–∞–∫, —á—Ç–æ–±—ã —Å–µ–∫—Ç–æ—Ä –ø–æ–±–µ–¥–∏—Ç–µ–ª—è –æ–∫–∞–∑–∞–ª—Å—è –ø–æ–¥ —Å—Ç—Ä–µ–ª–∫–æ–π:
          // –¢–æ –µ—Å—Ç—å –∫–æ–ª–µ—Å–æ –ø–æ–≤–µ—Ä–Ω—É—Ç–æ –Ω–∞: pointerAngle - winnerAngle (–æ–±–µ—Ä–Ω—ë–º –≤ 0..2pi)
          let finalRotation = (pointerAngle - winnerAngle) + 2 * Math.PI * 5; // 5 –æ–±–æ—Ä–æ—Ç–æ–≤ —Å–≤–µ—Ä—Ö—É

          let animStart = performance.now();

          function finalFrame(time) {
            const elapsed = time - animStart;
            const duration = 2000; // 2 —Å–µ–∫—É–Ω–¥—ã –¥–ª—è –¥–æ–∫—Ä—É—Ç–∫–∏

            const t = Math.min(elapsed / duration, 1);
            const easedT = easeOut(t);

            const currentRotation = rotate + easedT * (finalRotation - rotate);

            ctx.save();
            ctx.clearRect(0, 0, 300, 300);
            ctx.translate(150, 150);
            ctx.rotate(currentRotation + angleOffset);
            ctx.translate(-150, -150);
            drawWheelByList(spinPlayers);
            ctx.restore();

            if (t < 1) {
              requestAnimationFrame(finalFrame);
            } else {
              // –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
              showMessage(`üéâ –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: ${winnerName}! –í—ã–∏–≥—Ä—ã—à: ${winnings} üç¨ (8% –∫–æ–º–∏—Å—Å–∏—è: ${commission} üç¨)`, 'green');

              // –û–±–Ω–æ–≤–∏–º –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
              return fetch(`${BASE_URL}/check-auth`, { credentials: 'include' });
            }
          }

          requestAnimationFrame(finalFrame);

          return null; // –¥–∞–ª—å—à–µ –≤ —Ü–µ–ø–æ—á–∫–µ –ø—Ä–æ–º–∏—Å–æ–≤ –Ω–µ –∏–¥–µ–º –∑–¥–µ—Å—å
        })
        .then(userResp => {
          if (!userResp) return;
          if (userResp.ok) return userResp.json();
          throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –±–∞–ª–∞–Ω—Å');
        })
        .then(userData => {
          if (!userData) return;
          user.balance = userData.balance;
          balanceEl.textContent = user.balance;
        })
        .catch(err => {
          console.error(err);
          showMessage('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞', 'red');
        })
        .finally(() => {
          players = [];
          isAnimating = false;
          fetchNextSpin();
        });
    }
  }

  requestAnimationFrame(frame);
}



function startCountdown() {
  function updateTimer() {
    const now = Date.now();
    let diff = Math.floor((nextSpinTimestamp - now) / 1000);
    if (diff < 0) diff = 0;
    timerEl.textContent = diff;
  }
  updateTimer();
  const intervalId = setInterval(() => {
    updateTimer();
    if (Date.now() >= nextSpinTimestamp) {
      clearInterval(intervalId);
      scheduleSpinAnimation();
    }
  }, 500);
}

window.addEventListener('DOMContentLoaded', async () => {
  try {
    const resp = await fetch(`${BASE_URL}/check-auth`, { credentials: 'include' });
    if (!resp.ok) throw new Error('–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω');
    user = await resp.json();
    balanceEl.textContent = user.balance;

    await fetchPlayersAndDraw();
    setInterval(fetchPlayersAndDraw, 2000);
    await fetchNextSpin();
  } catch (err) {
    alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –≤–æ–π–¥–∏—Ç–µ.');
    window.location.href = 'index.html';
  }
});

joinBtn.addEventListener('click', async () => {
  const betValue = parseInt(document.getElementById('bet').value);
  if (!betValue || betValue <= 0) {
    showMessage('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Ç–∞–≤–∫–∞!', 'red');
    return;
  }
  if (betValue > user.balance) {
    showMessage('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!', 'red');
    return;
  }
  try {
    const resp = await fetch(`${BASE_URL}/roulette/join`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({ bet: betValue })
    });
    const data = await resp.json();
    if (!resp.ok) {
      throw new Error(data.error || '–û—à–∏–±–∫–∞ –ø—Ä–∏ join');
    }
    players = data.players;
    drawWheelByList(players);

    const check = await fetch(`${BASE_URL}/check-auth`, { credentials: 'include' });
    if (check.ok) {
      const upd = await check.json();
      user.balance = upd.balance;
      balanceEl.textContent = user.balance;
    }
    showMessage('–í—ã –≤ –∏–≥—Ä–µ. –ñ–¥—ë–º —Å–ø–∏–Ω–∞...', '#333');
  } catch (err) {
    showMessage(err.message, 'red');
  }
});
</script>
</body>
</html>
