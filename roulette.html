<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>üé° –†—É–ª–µ—Ç–∫–∞</title>
<link rel="stylesheet" href="style.css" />
<style>
  .wheel {
    width: 300px;
    height: 300px;
    border-radius: 50%;
    border: 10px solid #333;
    margin: 20px auto;
    position: relative;
    overflow: hidden;
  }
  .wheel canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
  .pointer {
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 20px solid transparent;
    border-right: 20px solid transparent;
    border-bottom: 30px solid red;
  }
  #message {
    font-weight: bold;
    margin-top: 10px;
    color: #333;
    text-align: center;
  }
  #countdown {
    font-size: 1rem;
    color: #555;
    text-align: center;
    margin-top: 5px;
  }
  #legend {
    max-width: 300px;
    margin: 10px auto;
    font-size: 0.9rem;
  }
  .legend-item {
    display: flex;
    align-items: center;
    margin-bottom: 4px;
  }
  .legend-color {
    width: 16px;
    height: 16px;
    border: 1px solid #000;
    margin-right: 8px;
  }
</style>
</head>
<body>
<main>
<h1>üé° –†—É–ª–µ—Ç–∫–∞</h1>
<p>–ë–∞–ª–∞–Ω—Å: <span id="balance">...</span> üç¨</p>

<div>
  <label for="bet">–°—Ç–∞–≤–∫–∞:</label>
  <input type="number" id="bet" min="1" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å—Ç–∞–≤–∫—É" />
  <button id="joinBtn">–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è</button>
</div>
<div id="countdown">–î–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–ø–∏–Ω–∞: <span id="timer">‚Äî</span> —Å–µ–∫</div>

<div class="wheel">
  <canvas id="canvas" width="300" height="300"></canvas>
  <div class="pointer"></div>
</div>

<div id="legend"></div>
<p id="message"></p>
<button onclick="window.location.href='mainPage.html'">‚¨ÖÔ∏è –ù–∞–∑–∞–¥</button>
</main>

<script>
const BASE_URL = 'https://fen4yaragithubio-production-9286.up.railway.app';

let user = null;
let players = [];
let spinPlayers = [];
let isAnimating = false;
let nextSpinTimestamp = null;

const balanceEl = document.getElementById('balance');
const messageEl = document.getElementById('message');
const joinBtn = document.getElementById('joinBtn');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const timerEl = document.getElementById('timer');
const legendEl = document.getElementById('legend');

function easeOut(t) {
  return 1 - Math.pow(1 - t, 3);
}

function showMessage(msg, color = '#333') {
  messageEl.textContent = msg;
  messageEl.style.color = color;
}

function drawWheelByList(list) {
  ctx.clearRect(0, 0, 300, 300);
  if (list.length === 0) return;
  const totalBet = list.reduce((s, p) => s + p.bet, 0);
  let startAngle = 0;
  list.forEach(p => {
    const angle = (p.bet / totalBet) * 2 * Math.PI;
    ctx.beginPath();
    ctx.moveTo(150, 150);
    ctx.arc(150, 150, 150, startAngle, startAngle + angle);
    ctx.fillStyle = p.color;
    ctx.fill();
    startAngle += angle;
  });
  renderLegend(list);
}

function renderLegend(list) {
  legendEl.innerHTML = '';
  list.forEach(p => {
    const item = document.createElement('div');
    item.className = 'legend-item';
    const colorBox = document.createElement('div');
    colorBox.className = 'legend-color';
    colorBox.style.backgroundColor = p.color;
    const text = document.createElement('div');
    text.textContent = `${p.username}: ${p.bet} üç¨`;
    item.appendChild(colorBox);
    item.appendChild(text);
    legendEl.appendChild(item);
  });
}

async function fetchPlayersAndDraw() {
  try {
    const resp = await fetch(`${BASE_URL}/roulette/players`, { credentials: 'include' });
    if (!resp.ok) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–≥—Ä–æ–∫–æ–≤');
    const data = await resp.json();
    players = data.players;
    if (!isAnimating) drawWheelByList(players);
  } catch (err) {
    console.error('fetchPlayersAndDraw:', err);
  }
}

async function fetchNextSpin() {
  try {
    const resp = await fetch(`${BASE_URL}/roulette/next-spin`, { credentials: 'include' });
    if (!resp.ok) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å next-spin');
    const data = await resp.json();
    nextSpinTimestamp = data.nextSpin;
    startCountdown();
  } catch (err) {
    console.error('fetchNextSpin:', err);
  }
}

function scheduleSpinAnimation() {
  if (isAnimating || nextSpinTimestamp === null) return;
  const now = Date.now();
  const delay = nextSpinTimestamp - now;
  if (delay <= 0) {
    animateSpin();
  } else {
    setTimeout(animateSpin, delay);
  }
}

function animateSpin() {
  if (isAnimating) return;

  spinPlayers = players.slice();

  if (spinPlayers.length < 2) {
    showMessage('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∏–≥—Ä–æ–∫–æ–≤ –¥–ª—è —Å–ø–∏–Ω–∞.', 'orange');
    isAnimating = false;
    fetchNextSpin();
    return;
  }

  isAnimating = true;
  showMessage('–ö—Ä—É—Ç–∏–º...');

  // –°–Ω–∞—á–∞–ª–∞ –ø–æ–ª—É—á–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç (–ø–æ–±–µ–¥–∏—Ç–µ–ª—è) –î–û –∞–Ω–∏–º–∞—Ü–∏–∏
  fetch(`${BASE_URL}/roulette/result`, { credentials: 'include' })
    .then(r => {
      if (!r.ok) throw new Error('–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞');
      return r.json();
    })
    .then(resData => {
      const winnerName = resData.winner;
      const totalBet = spinPlayers.reduce((s, p) => s + p.bet, 0);

      // –ù–∞–π–¥—ë–º —Å–µ–∫—Ç–æ—Ä –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
      let startAngle = 0;
      let winnerAngleStart = 0;
      let winnerAngleEnd = 0;
      for (const p of spinPlayers) {
        const angle = (p.bet / totalBet) * 2 * Math.PI;
        if (p.username === winnerName) {
          winnerAngleStart = startAngle;
          winnerAngleEnd = startAngle + angle;
          break;
        }
        startAngle += angle;
      }

      // –í—ã—á–∏—Å–ª—è–µ–º —Å–ª—É—á–∞–π–Ω—ã–π —É–≥–æ–ª –≤–Ω—É—Ç—Ä–∏ —Å–µ–∫—Ç–æ—Ä–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
      const winnerAngleCenter = (winnerAngleStart + winnerAngleEnd) / 2;

      // –°–∫–æ–ª—å–∫–æ –ø–æ–ª–Ω—ã—Ö –æ–±–æ—Ä–æ—Ç–æ–≤ —Å–¥–µ–ª–∞–µ–º (–Ω–∞–ø—Ä–∏–º–µ—Ä, 5)
      const fullSpins = 5;
      const finalAngle = fullSpins * 2 * Math.PI + (Math.PI / 2 - winnerAngleCenter);

      // –ê–Ω–∏–º–∞—Ü–∏—è: –æ—Ç 0 –¥–æ finalAngle
      const spinTime = 3000;
      const startTime = performance.now();

      function frame(now) {
        const progress = now - startTime;
        const frac = Math.min(progress / spinTime, 1);
        const angle = easeOut(frac) * finalAngle;

        ctx.save();
        ctx.clearRect(0, 0, 300, 300);
        ctx.translate(150, 150);
        ctx.rotate(angle);
        ctx.translate(-150, -150);
        drawWheelByList(spinPlayers);
        ctx.restore();

        if (progress < spinTime) {
          requestAnimationFrame(frame);
        } else {
          const commission = Math.floor(totalBet * 0.08);
          const winnings = totalBet - commission;
          showMessage(`üéâ –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: ${winnerName}! –í—ã–∏–≥—Ä—ã—à: ${winnings} üç¨ (8% –∫–æ–º–∏—Å—Å–∏—è: ${commission} üç¨)`, 'green');

          // –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å
          return fetch(`${BASE_URL}/check-auth`, { credentials: 'include' })
            .then(r2 => r2.ok ? r2.json() : Promise.reject('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –±–∞–ª–∞–Ω—Å'))
            .then(userData => {
              user.balance = userData.balance;
              balanceEl.textContent = user.balance;
            })
            .finally(() => {
              players = [];
              isAnimating = false;
              fetchNextSpin();
            });
        }
      }

      requestAnimationFrame(frame);
    })
    .catch(err => {
      console.error(err);
      showMessage('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–±–µ–¥–∏—Ç–µ–ª—è!', 'red');
      isAnimating = false;
      fetchNextSpin();
    });
}


function startCountdown() {
  function updateTimer() {
    const now = Date.now();
    let diff = Math.floor((nextSpinTimestamp - now) / 1000);
    if (diff < 0) diff = 0;
    timerEl.textContent = diff;
  }
  updateTimer();
  const intervalId = setInterval(() => {
    updateTimer();
    if (Date.now() >= nextSpinTimestamp) {
      clearInterval(intervalId);
      scheduleSpinAnimation();
    }
  }, 500);
}

window.addEventListener('DOMContentLoaded', async () => {
  try {
    const resp = await fetch(`${BASE_URL}/check-auth`, { credentials: 'include' });
    if (!resp.ok) throw new Error('–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω');
    user = await resp.json();
    balanceEl.textContent = user.balance;

    await fetchPlayersAndDraw();
    setInterval(fetchPlayersAndDraw, 2000);
    await fetchNextSpin();
  } catch (err) {
    alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –≤–æ–π–¥–∏—Ç–µ.');
    window.location.href = 'index.html';
  }
});

joinBtn.addEventListener('click', async () => {
  const betValue = parseInt(document.getElementById('bet').value);
  if (!betValue || betValue <= 0) {
    showMessage('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Ç–∞–≤–∫–∞!', 'red');
    return;
  }
  if (betValue > user.balance) {
    showMessage('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!', 'red');
    return;
  }
  try {
    const resp = await fetch(`${BASE_URL}/roulette/join`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({ bet: betValue })
    });
    const data = await resp.json();
    if (!resp.ok) {
      throw new Error(data.error || '–û—à–∏–±–∫–∞ –ø—Ä–∏ join');
    }
    players = data.players;
    drawWheelByList(players);

    const check = await fetch(`${BASE_URL}/check-auth`, { credentials: 'include' });
    if (check.ok) {
      const upd = await check.json();
      user.balance = upd.balance;
      balanceEl.textContent = user.balance;
    }
    showMessage('–í—ã –≤ –∏–≥—Ä–µ. –ñ–¥—ë–º —Å–ø–∏–Ω–∞...', '#333');
  } catch (err) {
    showMessage(err.message, 'red');
  }
});
</script>
</body>
</html>
