<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–†—É–ª–µ—Ç–∫–∞ ¬∑ 320xbet</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="game-page">
    <header class="glass-card top-bar">
      <div>
        <p class="eyebrow">–†–µ–∂–∏–º</p>
        <h1>üéØ –†—É–ª–µ—Ç–∫–∞</h1>
        <p class="muted">–ß–µ–º –≤—ã—à–µ —Å—Ç–∞–≤–∫–∞, —Ç–µ–º —à–∏—Ä–µ —Å–µ–∫—Ç–æ—Ä –Ω–∞ –∫–æ–ª–µ—Å–µ. –°–æ–±–µ—Ä–∏ –±–∞–Ω–∫ –∏ —Å–æ—Ä–≤–∏ –∫—É—à.</p>
      </div>
      <button class="btn-outline" onclick="window.location.href='mainPage.html'">‚¨Ö –ù–∞–∑–∞–¥</button>
    </header>

    <section class="crash-layout">
      <article class="glass-card crash-panel">
        <div class="balance-pill">–ë–∞–ª–∞–Ω—Å: <span id="balance">...</span> üç¨</div>

        <label for="bet" class="muted">–°—Ç–∞–≤–∫–∞</label>
        <div class="inline-form">
          <input type="number" id="bet" min="1" class="input-field" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å—Ç–∞–≤–∫—É" />
          <button id="joinBtn" class="btn-primary" style="width:auto">–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è</button>
        </div>

        <div id="countdown" class="notice">
          <span id="countdown-text">–û–∂–∏–¥–∞–Ω–∏–µ –≤—Ç–æ—Ä–æ–≥–æ –∏–≥—Ä–æ–∫–∞‚Ä¶</span>
          <span id="timer"></span>
        </div>

        <p id="message" class="message"></p>
      </article>

      <article class="glass-card wheel-wrapper">
        <div class="roulette-strip-card">
          <div class="roulette-strip-viewport" id="rouletteStripViewport">
            <div class="roulette-strip" id="rouletteStrip"></div>
            <div class="roulette-strip-pointer"></div>
          </div>
          <p class="muted" style="margin-top:8px; text-align:center;">–®–∞–Ω—Å –Ω–∞ –≤—ã–∏–≥—Ä—ã—à –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª–µ–Ω —Ä–∞–∑–º–µ—Ä—É —Å–µ–≥–º–µ–Ω—Ç–∞</p>
        </div>
        <div class="glass-card" style="width:100%; padding:18px">
          <p class="muted">–£—á–∞—Å—Ç–Ω–∏–∫–∏ –∏ —Å—Ç–∞–≤–∫–∏</p>
          <div id="legend"></div>
        </div>
      </article>

      <article class="glass-card history-card">
        <p class="eyebrow">–ò—Å—Ç–æ—Ä–∏—è —Å–ø–∏–Ω–æ–≤</p>
        <div id="rouletteHistory" class="history-list"></div>
      </article>
    </section>
  </div>

  <div id="rouletteModal" class="modal-overlay hidden">
    <div class="modal-content glass-card">
      <button id="rouletteModalClose" class="modal-close" aria-label="–ó–∞–∫—Ä—ã—Ç—å">‚úï</button>
      <div id="rouletteModalBody"></div>
    </div>
  </div>

  <script src="script/utils.js"></script>
  <script>
    const BASE_URL = 'https://fen4yaragithubio-production.up.railway.app';
    let user = null;
    let players = [];
    let isAnimating = false;
    let nextSpinTimestamp = null;
    let countdownInterval = null;
    let rouletteHistoryCache = [];
    let lastBet = 0;

    const balanceEl = document.getElementById('balance');
    const messageEl = document.getElementById('message');
    const joinBtn = document.getElementById('joinBtn');
    const stripEl = document.getElementById('rouletteStrip');
    const stripViewportEl = document.getElementById('rouletteStripViewport');
    const countdownTextEl = document.getElementById('countdown-text');
    const timerEl = document.getElementById('timer');
    const legendEl = document.getElementById('legend');
    const historyEl = document.getElementById('rouletteHistory');
    const detailModal = document.getElementById('rouletteModal');
    const detailModalBody = document.getElementById('rouletteModalBody');
    const detailModalClose = document.getElementById('rouletteModalClose');
    const COLOR_FALLBACKS = ['#ff5f9e', '#7f5af0', '#34d399', '#facc15', '#38bdf8', '#fb7185'];
    let stripMeta = null;
    let lastStripSnapshot = [];
    let historyLocked = false;

   // –ü–ª–∞–≤–Ω–æ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏–∏
    function easeOut(t) {
      return 1 - Math.pow(1 - t, 3);
    }

    function placeholderSegments() {
      return Array.from({ length: 6 }, (_, idx) => ({
        username: '',
        bet: 1,
        color: idx % 2 === 0 ? 'rgba(255, 255, 255, 0.05)' : 'rgba(255, 255, 255, 0.12)'
      }));
    }

    function showMessage(msg, color = '#333') {
      messageEl.textContent = msg;
      messageEl.style.color = color;
    }

    function cloneSegments(list) {
      return list.map((segment) => ({
        username: segment.username,
        bet: Number(segment.bet) || 1,
        color: segment.color
      }));
    }

    function buildStrip(list, options = {}) {
      const { rememberSnapshot = true } = options;
      const hasData = Array.isArray(list) && list.length > 0;
      stripEl.innerHTML = '';
      stripMeta = null;

      if (!hasData) {
        renderLegend([]);
      }

      const sourceSegments = hasData ? list : placeholderSegments();

      const segments = sourceSegments.map((segment, idx) => {
        return {
          ...segment,
          bet: Number(segment.bet) || 1,
          color: segment.color || COLOR_FALLBACKS[idx % COLOR_FALLBACKS.length]
        };
      });

      const totalBet = segments.reduce((s, p) => s + p.bet, 0) || 1;
      const targetPatternWidth = 1400;
      const minPxPerTicket = 4;
      const maxPxPerTicket = 28;
      const pxPerTicket = Math.min(maxPxPerTicket, Math.max(minPxPerTicket, targetPatternWidth / totalBet));

      let cumulativeTickets = 0;
      let patternWidth = 0;
      const fragment = document.createDocumentFragment();

      segments.forEach((segment) => {
        const segmentWidth = segment.bet * pxPerTicket;
        const segEl = document.createElement('div');
        segEl.className = 'roulette-segment';
        segEl.style.backgroundColor = segment.color;
        segEl.style.width = `${segmentWidth}px`;

        const label = document.createElement('span');
        label.className = 'roulette-segment-name';
        label.textContent = segment.username;
        segEl.appendChild(label);

        fragment.appendChild(segEl);

        segment.startTicket = cumulativeTickets;
        segment.endTicket = cumulativeTickets + segment.bet;
        segment.startPx = patternWidth;
        segment.endPx = patternWidth + segmentWidth;

        cumulativeTickets += segment.bet;
        patternWidth += segmentWidth;
      });

      stripEl.appendChild(fragment);
      stripEl.style.transform = 'translateX(0px)';
      stripMeta = {
        totalBet,
        pxPerTicket,
        patternWidth,
        segments,
        baseHTML: stripEl.innerHTML,
        repeats: 1
      };
      if (hasData) {
        renderLegend(segments);
        if (rememberSnapshot) {
          lastStripSnapshot = cloneSegments(segments);
        }
      } else {
        renderLegend([]);
      }
    }

    function prepareStripForSpin(laps) {
      if (!stripEl || !stripMeta?.baseHTML) return 1;
      const repeats = Math.max(3, laps + 2);
      let combined = '';
      for (let i = 0; i < repeats; i++) {
        combined += stripMeta.baseHTML;
      }
      stripEl.innerHTML = combined;
      stripMeta.repeats = repeats;
      stripEl.style.transform = 'translateX(0px)';
      return repeats;
    }

    // –†–∏—Å—É–µ–º –ª–µ–≥–µ–Ω–¥—É
    function renderLegend(list) {
      legendEl.innerHTML = '';
      if (!list.length) {
        const empty = document.createElement('div');
        empty.className = 'legend-item muted';
        empty.textContent = '–û–∂–∏–¥–∞–µ–º –∏–≥—Ä–æ–∫–æ–≤ –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–ø–∏–Ω–∞';
        legendEl.appendChild(empty);
        return;
      }

      list.forEach((p, idx) => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        const left = document.createElement('div');
        left.style.display = 'flex';
        left.style.alignItems = 'center';
        left.style.gap = '10px';
        const colorBox = document.createElement('div');
        colorBox.className = 'legend-color';
        colorBox.style.backgroundColor = p.color || COLOR_FALLBACKS[idx % COLOR_FALLBACKS.length];
        const name = document.createElement('div');
        name.textContent = p.username;
        left.appendChild(colorBox);
        left.appendChild(name);

        const bet = document.createElement('strong');
        bet.textContent = formatCandy(p.bet);

        item.appendChild(left);
        item.appendChild(bet);
        legendEl.appendChild(item);
      });
    }

    function renderHistory(history) {
      if (!historyEl) return;
      rouletteHistoryCache = history || [];
      historyEl.innerHTML = '';
      if (!rouletteHistoryCache.length) {
        const empty = document.createElement('div');
        empty.className = 'history-item muted';
        empty.textContent = '–ò—Å—Ç–æ—Ä–∏—è –ø–æ—è–≤–∏—Ç—Å—è –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–µ—Ä–≤–æ–≥–æ —Å–ø–∏–Ω–∞';
        historyEl.appendChild(empty);
        return;
      }
      rouletteHistoryCache.forEach((round) => {
        const card = document.createElement('div');
        card.className = 'history-item clickable';
        const date = new Date(round.timestamp);
        const header = document.createElement('div');
        header.innerHTML = `<strong>${date.toLocaleTimeString('ru-RU')}</strong> ‚Äî ${round.winner}`;
        const body = document.createElement('div');
        body.className = 'muted';
        const ticketInfo = typeof round.winningTicket === 'number'
          ? `, –±–∏–ª–µ—Ç ${round.winningTicket.toFixed(2)}`
          : '';
        body.textContent = `–ë–∞–Ω–∫: ${formatCandy(round.totalBet)}${ticketInfo}`;
        card.appendChild(header);
        card.appendChild(body);
        card.addEventListener('click', () => openRouletteHistoryModal(round));
        historyEl.appendChild(card);
      });
    }

    function openRouletteHistoryModal(round) {
      if (!detailModal || !detailModalBody) return;
      const date = new Date(round.timestamp).toLocaleString('ru-RU');
      const ticketInfo = typeof round.winningTicket === 'number'
        ? round.winningTicket.toFixed(2)
        : '‚Äî';
      const playersList = (round.players || [])
        .map((p) => `<li><strong>${p.username}</strong> ‚Äî —Å—Ç–∞–≤–∫–∞ ${formatCandy(p.bet)}</li>`)
        .join('');

      detailModalBody.innerHTML = `
        <p class="muted">${date}</p>
        <h2>–ü–æ–±–µ–¥–∏—Ç–µ–ª—å: ${round.winner}</h2>
        <p>–ë–∞–Ω–∫: ${formatCandy(round.totalBet)} ¬∑ –ë–∏–ª–µ—Ç: ${ticketInfo}</p>
        <ul class="history-players highlight">${playersList || '<li>–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</li>'}</ul>
      `;
      detailModal.classList.remove('hidden');
    }

    function closeRouletteHistoryModal() {
      detailModal?.classList.add('hidden');
    }

    detailModalClose?.addEventListener('click', closeRouletteHistoryModal);
    detailModal?.addEventListener('click', (e) => {
      if (e.target === detailModal) closeRouletteHistoryModal();
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closeRouletteHistoryModal();
    });

    // 1) –ü–æ–ª—É—á–∞–µ–º –∏–≥—Ä–æ–∫–æ–≤ + nextSpin + serverTime (–∫–∞–∂–¥—ã–µ 500 –º—Å)
    async function fetchPlayersAndDraw() {
      try {
        const resp = await fetch(`${BASE_URL}/roulette/players`, { credentials: 'include' });
        if (!resp.ok) {
          if (resp.status === 401) throw new Error('–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω');
          else throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–≥—Ä–æ–∫–æ–≤');
        }
        const data = await resp.json();
        const incomingPlayers = Array.isArray(data.players) ? data.players : [];
        players = incomingPlayers;
        if (!isAnimating) {
          if (incomingPlayers.length) {
            buildStrip(incomingPlayers);
          } else if (lastStripSnapshot.length) {
            buildStrip(lastStripSnapshot, { rememberSnapshot: false });
          } else {
            buildStrip([]);
          }
        }

        // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –ª–æ–∫–∞–ª—å–Ω—É—é –º–µ—Ç–∫—É nextSpinTimestamp:
        if (data.nextSpin !== null) {
          const offset = Date.now() - data.serverTime;
          const localNext = data.nextSpin + offset;
          if (localNext !== nextSpinTimestamp) {
            nextSpinTimestamp = localNext;
            startCountdown();
          }
        } else if (nextSpinTimestamp !== null) {
          // –ï—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä –≤–¥—Ä—É–≥ –≤–µ—Ä–Ω—É–ª null, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –ª–æ–∫–∞–ª—å–Ω–æ
          nextSpinTimestamp = null;
          startCountdown();
        }
      } catch (err) {
        console.error('fetchPlayersAndDraw:', err);
      }
    }

    async function loadRouletteHistory() {
      if (historyLocked) return;
      try {
        const resp = await fetch(`${BASE_URL}/roulette/history`, { credentials: 'include' });
        if (!resp.ok) {
          if (resp.status === 401) throw new Error('–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω');
          return;
        }
        const data = await resp.json();
        renderHistory(data);
      } catch (err) {
        console.error('roulette history:', err);
      }
    }

    // 2) –§—É–Ω–∫—Ü–∏—è –æ–ø—Ä–æ—Å–∞ /next-spin (–¥—É–±–ª–∏—Ä—É–µ—Ç –ª–æ–≥–∏–∫—É, –Ω–æ –º–æ–∂–µ—Ç –ø—Ä–∏–≥–æ–¥–∏—Ç—å—Å—è)
    async function fetchNextSpin() {
      try {
        const resp = await fetch(`${BASE_URL}/roulette/next-spin`, { credentials: 'include' });
        if (!resp.ok) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å next-spin');
        const data = await resp.json();
        if (data.nextSpin !== null) {
          const offset = Date.now() - data.serverTime;
          const localNext = data.nextSpin + offset;
          if (localNext !== nextSpinTimestamp) {
            nextSpinTimestamp = localNext;
            startCountdown();
          }
        } else if (nextSpinTimestamp !== null) {
          nextSpinTimestamp = null;
          startCountdown();
        }
      } catch (err) {
        console.error('fetchNextSpin:', err);
      }
    }

    // 3) –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞—Ç–Ω—ã–π –æ—Ç—Å—á—ë—Ç, –æ–¥–∏–Ω —Ä–∞–∑ –≤—ã–∑—ã–≤–∞–µ–º animateSpin()
    function startCountdown() {
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }

      if (nextSpinTimestamp === null) {
        countdownTextEl.textContent = '–û–∂–∏–¥–∞–Ω–∏–µ –≤—Ç–æ—Ä–æ–≥–æ –∏–≥—Ä–æ–∫–∞‚Ä¶';
        timerEl.textContent = '';
        return;
      }

      countdownTextEl.textContent = '–î–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–ø–∏–Ω–∞:';
      function updateTimer() {
        const now = Date.now();
        let remainingMs = nextSpinTimestamp - now;
        let secondsLeft = remainingMs > 0 ? Math.ceil(remainingMs / 1000) : 0;
        timerEl.textContent = secondsLeft + ' —Å';

        if (now >= nextSpinTimestamp) {
          clearInterval(countdownInterval);
          countdownInterval = null;
          animateSpin();
        }
      }
      updateTimer();
      countdownInterval = setInterval(updateTimer, 200);
    }

    // 4) –ê–Ω–∏–º–∞—Ü–∏—è —Å–ø–∏–Ω–∞
    async function refreshBalance() {
      try {
        const resp = await fetch(`${BASE_URL}/check-auth`, { credentials: 'include' });
        if (!resp.ok) throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –±–∞–ª–∞–Ω—Å');
        const userData = await resp.json();
        user = userData;
        balanceEl.textContent = formatCoins(user.balance);
        return userData;
      } catch (err) {
        console.error('refreshBalance:', err);
        return null;
      }
    }

    async function animateSpin() {
      if (isAnimating) return;
      isAnimating = true;
      historyLocked = true;

      let resultData;
      try {
        const r = await fetch(`${BASE_URL}/roulette/result`, { credentials: 'include' });
        if (!r.ok) {
          console.warn('–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø–æ–ø—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ 500 –º—Å');
          isAnimating = false;
          setTimeout(animateSpin, 500);
          return;
        }
        resultData = await r.json();
      } catch (err) {
        console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ /roulette/result:', err);
        isAnimating = false;
        setTimeout(animateSpin, 1000);
        return;
      }

      const spinPlayers = resultData.players;
      const winnerUsername = resultData.winner;
      const totalPot = resultData.totalBet;
      if (!spinPlayers || spinPlayers.length < 2) {
        showMessage('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∏–≥—Ä–æ–∫–æ–≤ –¥–ª—è —Å–ø–∏–Ω–∞.', 'orange');
        isAnimating = false;
        return;
      }

      showMessage('–ö–æ–ª–µ—Å–æ –∫—Ä—É—Ç–∏—Ç—Å—è‚Ä¶');

      const totalBet = spinPlayers.reduce((s, p) => s + p.bet, 0) || 1;
      const winningTicket = typeof resultData.winningTicket === 'number'
        ? resultData.winningTicket
        : totalBet / 2;
      const clampedTicket = Math.min(Math.max(winningTicket, 0), totalBet);

      if (!stripMeta) {
        buildStrip(spinPlayers);
      }

      if (!stripMeta) {
        showMessage('–û—à–∏–±–∫–∞ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ —Ä—É–ª–µ—Ç–∫–∏.', 'red');
        isAnimating = false;
        historyLocked = false;
        return;
      }

      const { pxPerTicket, patternWidth } = stripMeta || { pxPerTicket: 4, patternWidth: totalBet * 4 };
      const viewportWidth = stripViewportEl ? stripViewportEl.clientWidth : 600;
      const minTurns = 3;
      const maxTurns = 6;
      const laps = minTurns + Math.floor(Math.random() * (maxTurns - minTurns + 1));
      const repeats = prepareStripForSpin(laps);
      const totalStripWidth = patternWidth * repeats;
      const maxTranslate = Math.max(totalStripWidth - viewportWidth, 0);
      const ticketOffsetPx = clampedTicket * pxPerTicket;
      const travelDistance = laps * patternWidth + ticketOffsetPx;
      const desiredTranslate = travelDistance - viewportWidth / 2;
      const finalTranslate = Math.min(Math.max(desiredTranslate, 0), maxTranslate);

      const spinDuration = 5000;
      const startTime = performance.now();

      function frame(now) {
        const elapsed = now - startTime;
        const t = Math.min(elapsed / spinDuration, 1);
        const eased = easeOut(t);
        const currentDistance = eased * finalTranslate;
        const translateX = -currentDistance;
        stripEl.style.transform = `translateX(${translateX}px)`;

      if (t < 1) {
        requestAnimationFrame(frame);
      } else {
        const ticketNote = typeof winningTicket === 'number'
          ? ` (–±–∏–ª–µ—Ç ${winningTicket.toFixed(2)})`
          : '';
        showMessage(`üéâ –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: ${winnerUsername}! –í—ã–∏–≥—Ä—ã—à: ${formatCandy(totalPot)}${ticketNote}`, 'green');
        refreshBalance()
          .finally(() => {
            players = [];
            isAnimating = false;
            historyLocked = false;
            loadRouletteHistory();
          });
      }
      }

      requestAnimationFrame(frame);
    }

    // 5) –ü—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å—Ä–∞–∑—É –ø–æ–ª—É—á–∞–µ–º –∏–≥—Ä–æ–∫–æ–≤ + nextSpin + serverTime
    window.addEventListener('DOMContentLoaded', async () => {
      try {
        const resp = await fetch(`${BASE_URL}/check-auth`, { credentials: 'include' });
        if (!resp.ok) throw new Error('–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω');
        user = await resp.json();
        if (lastBet > 0) {
          document.getElementById('bet').value = lastBet;
        }
        balanceEl.textContent = formatCoins(user.balance);

        await fetchPlayersAndDraw();
        await loadRouletteHistory();
        setInterval(fetchPlayersAndDraw, 500);
        setInterval(fetchNextSpin, 500);
        setInterval(loadRouletteHistory, 4000);
      } catch (err) {
        alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –≤–æ–π–¥–∏—Ç–µ.');
        window.location.href = 'index.html';
      }
    });

    // 6) –ü—Ä–∏ –∫–ª–∏–∫–µ ¬´–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è¬ª
    joinBtn.addEventListener('click', async () => {
      const betValue = parseInt(document.getElementById('bet').value);
      if (!betValue || betValue <= 0) {
        showMessage('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Ç–∞–≤–∫–∞!', 'red');
        return;
      }
      if (betValue > user.balance) {
        showMessage('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!', 'red');
        return;
      }
      try {
        const resp = await fetch(`${BASE_URL}/roulette/join`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ bet: betValue })
        });
        const data = await resp.json();
        if (!resp.ok) {
          throw new Error(data.error || '–û—à–∏–±–∫–∞ –ø—Ä–∏ join');
        }

        players = data.players;
        if (!isAnimating) {
          if (players.length) {
            buildStrip(players);
          } else if (lastStripSnapshot.length) {
            buildStrip(lastStripSnapshot, { rememberSnapshot: false });
          } else {
            buildStrip([]);
          }
        }

        await refreshBalance();
        showMessage('–í—ã –≤ –∏–≥—Ä–µ. –ñ–¥—ë–º —Å–ø–∏–Ω–∞...', '#333');
        lastBet = betValue;
        document.getElementById('bet').value = betValue;

        // –¢–µ–ø–µ—Ä—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ª–æ–∫–∞–ª—å–Ω—É—é –º–µ—Ç–∫—É –¥–ª—è –æ—Ç—Å—á—ë—Ç–∞
        if (data.nextSpin !== null) {
          const offset = Date.now() - data.serverTime;
          nextSpinTimestamp = data.nextSpin + offset;
        } else {
          nextSpinTimestamp = null;
        }
        startCountdown();
      } catch (err) {
        showMessage(err.message, 'red');
      }
    });
  </script>
</body>
</html>
